package glazer.englard.tetris;

import java.awt.Color;

public class IPiece extends Piece implements PieceInterface {

	public IPiece(int maxC) {
		super(maxC);
		super.color = new Color(31, 190, 214); // light blue
		startPosition();

	}

	private void startPosition() {

		super.row1 = 0;
		super.row2 = 0;
		super.row3 = 0;
		super.row4 = 0;
		super.column1 = 3;
		super.column2 = 4;
		super.column3 = 5;
		super.column4 = 6;

	}

	public void turn() {
		int turnType = super.turnCounter % 4;
		switch (turnType) {
		case 1:
			// validate Turn
			if ((super.row4) > super.MaxRow) {
				return;
			}
			// everything in c3, 3 stays same
			super.row1 += 1;
			super.row2 += 2;
			super.row4 += 3;
			super.column1 = super.column3;
			super.column2 = super.column3;
			super.column4 = super.column3;

			break;
		case 2:
			// validate Turn - when it is all way to the right or when its one
			// or two from left it needs to turn diff
			/*
			 * if(super.column4 +1 >super.MaxColumn){ //all way to right - turn
			 * and move everything one to the left super.row1 = super.row2;
			 * super.row3 = super.row2; super.row4 = super.row2; super.column1
			 * -= 3; super.column3 -= 2; super.column2 -=1; return;
			 * 
			 * } else if ((super.column1 - 2 < 0) ) { //all the way to the left
			 * or second to left - turn piece and move it 2 right super.row1 =
			 * super.row2; super.row3 = super.row2; super.row4 = super.row2;
			 * super.column2 += 2; super.column3 += 1; super.column4 += 3;
			 * return;
			 * 
			 * }
			 */
			// everything inr2, 2 stays same
			super.row1 = super.row2;
			super.row3 = super.row2;
			super.row4 = super.row2;
			super.column1 -= 2;
			super.column3 -= 1;
			super.column4 += 1;

			break;
		case 3:
			// no validation needed

			// everything goes into r3, r3 stays same
			super.row1 -= 2;
			super.row2 -= 1;
			super.row4 += 1;
			super.column1 = super.column3;
			super.column2 = super.column3;
			super.column4 = super.column3;

			break;
		case 0:
			// validate
			// if(super.column1 -1 <0 || super.column4 +2 > super.MaxColumn){
			// return;
			// }
			// goes into r1, r1 and c2 stay
			super.row2 = super.row1;
			super.row3 = super.row1;
			super.row4 = super.row1;
			super.column1 -= 1;
			super.column3 += 1;
			super.column4 += 2;

			break;

		}
		super.turnCounter++;
		while (super.column4 > super.MaxColumn) {
			super.moveLeft();
		}
		while(super.column1 < 0){
			super.moveRight();
		}

	}

	@Override
	public boolean moveRightValidate() {
		// piece 4 is always most right or equal to other pieces so check only
		// that piece
		return super.column4 < super.MaxColumn;

	}

	@Override
	public boolean moveLeftValidate() {
		// piece 1 is right most piece always
		return super.column1 > 0;

	}
}
