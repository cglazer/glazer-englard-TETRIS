package glazer.englard.tetris;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class TetrisFrame extends JFrame implements KeyListener {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Container container;
	private JPanel gridPanel;
	private JButton start;
	private JButton moveRight;
	private JButton moveLeft;
	private JButton moveDown;
	private JButton turn;
	private JLabel[][] labels;
	private int column;
	private JLabel gameOver;
	private HashMap<JLabel, Boolean> map;
	private ScheduledExecutorService executor;
	private JPanel northPanel;
	private int numCols;
	private int numRows;
	private Piece pieceShape;
	private Color color;
	private int coloredRow1;
	private int coloredRow2;
	private int coloredRow3;
	private int coloredRow4;
	private int coloredColumn1;
	private int coloredColumn2;
	private int coloredColumn3;
	private int coloredColumn4;
	private int row1;
	private int row2;
	private int row3;
	private int row4;
	private int column1;
	private int column2;
	private int column3;
	private int column4;
	private HashSet<JLabel> labelSet;
	

	public TetrisFrame() {
		setSize(370, 620);
		setTitle("Tetris");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		this.container = getContentPane();
		this.gridPanel = new JPanel();
		this.start = new JButton("START");
		this.moveLeft = new JButton("LEFT");
		this.moveRight = new JButton("RIGHT");
		this.moveDown = new JButton("DOWN");
		this.turn = new JButton("TURN");
		this.northPanel = new JPanel();
		this.labels = new JLabel[30][10];
		this.column = 5;
		this.map = new HashMap<JLabel, Boolean>();
		this.gameOver = new JLabel();

		this.numCols = 10;
		this.numRows = 30;
		// this.pieceShape = new IPiece();
		// this.pieceShape=
		chooseShape();
		this.color = pieceShape.getColor();
		// color = pieceShape.getColor();
		row1 = pieceShape.getRow1();
		column1 = pieceShape.getColumn1();
		row2 = pieceShape.getRow2();
		column2 = pieceShape.getColumn2();
		row3 = pieceShape.getRow3();
		column3 = pieceShape.getColumn3();
		row4 = pieceShape.getRow4();
		column4 = pieceShape.getColumn4();
		labelSet = new HashSet<JLabel>();
		setComponents();
		addComponents();
	}

	public void setComponents() {
		this.container.setLayout(new BorderLayout());
		this.gridPanel.setLayout(new GridLayout(30, 10));
		this.northPanel.setLayout(new FlowLayout());
	}

	public void addComponents() {

		this.container.add(this.gridPanel, BorderLayout.CENTER);
		this.northPanel.add(start);
		this.northPanel.add(this.turn);
		this.northPanel.add(this.moveLeft);
		this.northPanel.add(this.moveRight);
		this.northPanel.add(this.moveDown);
		this.container.add(this.northPanel, BorderLayout.NORTH);
		this.container.add(this.gameOver, BorderLayout.SOUTH);
		this.container.addKeyListener(this);
		this.container.setFocusable(true);

		for (int i = 0; i < numRows; i++) {
			for (int x = 0; x < numCols; x++) {
				this.labels[i][x] = new JLabel();
				gridPanel.add(this.labels[i][x]);
				labels[i][x].setBorder(BorderFactory
						.createLineBorder(Color.GRAY));
			}
		}
		this.start.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				for (int i = 0; i < numRows; i++) {
					for (int x = 0; x < numCols; x++) {
						labels[i][x].setBackground(Color.LIGHT_GRAY);
						labels[i][x].setOpaque(true);
						map.put(labels[i][x], false);
					}
				}
				start.setText("NEW GAME");
				gameLoop();
			}
		});
		this.moveLeft.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				
				if (pieceShape.moveLeftValidate()
						&& (!map.get(labels[row1][column1 - 1]) || labelSet
						.contains(labels[row1][column1]))
						&& (!map.get(labels[row2][column2 - 1]) || labelSet
								.contains(labels[row2][column2]))
						&& (!map.get(labels[row3][column3 - 1]) || labelSet
								.contains(labels[row3][column3]))
						&& (!map.get(labels[row4][column4 - 1]) || labelSet
								.contains(labels[row4][column4]))) {

					pieceShape.moveLeft();
					refreshColumnValues();
				}

			}

		});
		this.moveRight.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				if (pieceShape.moveRightValidate() &&(!map.get(labels[row1][column1 + 1]) || labelSet
						.contains(labels[row1][column1]))
						&& (!map.get(labels[row2][column2 + 1]) || labelSet
								.contains(labels[row2][column2]))
						&& (!map.get(labels[row3][column3 + 1]) || labelSet
								.contains(labels[row3][column3]))
						&& (!map.get(labels[row4][column4 + 1]) || labelSet
								.contains(labels[row4][column4]))) {
					pieceShape.moveRight();
					refreshColumnValues();
				}
			}
		});
		this.moveDown.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				System.out.println("down");
				if (row1 + 2 < numRows && row2 + 2 < numRows
						&& row3 + 2 < numRows && row4 + 2 < numRows
						&& !map.get(labels[row1 + 2][column1])
						&& !map.get(labels[row2 + 2][column2])
						&& !map.get(labels[row3 + 2][column3])
						&& !map.get(labels[row4 + 2][column4])) {
					pieceShape.moveDownFast();
					refreshRowValues();

				}
			}

		});
		this.turn.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				pieceShape.turn();
				refreshRowValues();
				refreshColumnValues();

			}
		});
	}

	public void gameLoop() {
		this.executor = Executors.newScheduledThreadPool(1);
		executor.scheduleAtFixedRate(gameRunnable, 0, 1, TimeUnit.SECONDS);
	}

	public void checkGameOver() {
		for (int i = 0; i < numCols; i++) {
			if (map.get(labels[0][i]) && map.get(labels[1][i])
					&& !labelSet.contains(labels[1][i])) {
				gameOver();

			}
		}
	}

	Runnable gameRunnable = new Runnable() {

		public void run() // this becomes the loop
		{
			checkGameOver();
			if (row1 > 0) {
				labels[coloredRow1][coloredColumn1]
						.setBackground(Color.LIGHT_GRAY);
				map.put(labels[coloredRow1][coloredColumn1], false);
			}
			if (row2 > 0) {
				labels[coloredRow2][coloredColumn2]
						.setBackground(Color.LIGHT_GRAY);
				map.put(labels[coloredRow2][coloredColumn2], false);
			}
			if (row3 > 0) {
				labels[coloredRow3][coloredColumn3]
						.setBackground(Color.LIGHT_GRAY);
				map.put(labels[coloredRow3][coloredColumn3], false);
			}
			if (row4 > 0) {
				labels[coloredRow4][coloredColumn4]
						.setBackground(Color.LIGHT_GRAY);
				map.put(labels[coloredRow4][coloredColumn4], false);
			}
			labelSet.clear();
			// paintPiece();
			if (row1 >= 0) {
				labels[row1][column1].setBackground(color);
				labels[row1][column1].setOpaque(true);
				map.put(labels[row1][column1], true);
				labelSet.add(labels[row1][column1]);
			}
			if (row2 >= 0) {
				labels[row2][column2].setBackground(color);
				labels[row2][column2].setOpaque(true);
				map.put(labels[row2][column2], true);
				labelSet.add(labels[row2][column2]);
			}
			if (row3 >= 0) {
				labels[row3][column3].setBackground(color);
				labels[row3][column3].setOpaque(true);
				map.put(labels[row3][column3], true);
				labelSet.add(labels[row3][column3]);
			}
			if (row4 >= 0) {
				labels[row4][column4].setBackground(color);
				labels[row4][column4].setOpaque(true);
				map.put(labels[row4][column4], true);
				labelSet.add(labels[row4][column4]);
			}
			coloredRow1 = row1;
			coloredRow2 = row2;
			coloredRow3 = row3;
			coloredRow4 = row4;
			coloredColumn1 = column1;
			coloredColumn2 = column2;
			coloredColumn3 = column3;
			coloredColumn4 = column4;
			repaint();

			pieceShape.moveDown();
			refreshRowValues();
			// /////////////////////////////////////////////////////////////////

			if ((map.get(labels[row1][column1]) && !labelSet
					.contains(labels[row1][column1]))
					|| (map.get(labels[row2][column2]) && !labelSet
							.contains(labels[row2][column2]))
					|| (map.get(labels[row3][column3]) && !labelSet
							.contains(labels[row3][column3]))
					|| (map.get(labels[row4][column4]) && !labelSet
							.contains(labels[row4][column4]))
					|| row1 == 28
					|| row2 == 28 || row3 == 28 || row4 == 28) {
				checkFinishedRow();
				chooseShape();
				color = pieceShape.getColor();
				row1 = pieceShape.getRow1();
				column1 = pieceShape.getColumn1();
				row2 = pieceShape.getRow2();
				column2 = pieceShape.getColumn2();
				row3 = pieceShape.getRow3();
				column3 = pieceShape.getColumn3();
				row4 = pieceShape.getRow4();
				column4 = pieceShape.getColumn4();
				// System.out.println(row1 + ", " + column1);
				for (JLabel s : labelSet) {
					System.out.println("contained");
				}
			}
		}

	};

	public void checkFinishedRow() {
		boolean fullLine = true;
		int checkCol;
		for (int i = 0; i < numRows; i++) {
			checkCol = 0;
			fullLine = true;
			while (fullLine) {
				if (!map.get(labels[i][checkCol])) {
					fullLine = false;
				} else {
					if (checkCol == 9) {
						for (int x = 0; x < numCols; x++) {
							labels[i][x].setBackground(Color.LIGHT_GRAY);
							map.put(labels[i][x], false);
						}
						moveDown(i);
						repaint();
						fullLine = false;
					}

					checkCol++;

				}

			}
		}
	}

	/**
	 * Moves everything above this row down a row
	 * 
	 * @param column
	 */
	private void moveDown(int cRow) {
		// TODO Auto-generated method stub
		for (int i = cRow; i > 0; i--) {
			for (int x = 0; x < numCols; x++) {
				labels[i][x].setBackground(labels[i - 1][x].getBackground());
				map.put(labels[i][x], map.get(labels[i - 1][x]));
			}
		}
		for (int i = 0; i < numCols; i++) {
			map.put(labels[0][i], false);
			labels[0][i].setBackground(Color.LIGHT_GRAY);
		}
	}

	private void chooseShape() {
		Random newShape = new Random();
		int numShape = newShape.nextInt(7);
		switch (1) {
		case 0:
			this.pieceShape = new LPiece(this.numCols);
			System.out.println("L");
			break;
		case 1:
			System.out.println("I");
			this.pieceShape = new IPiece(this.numCols);
			break;
		case 2:
			System.out.println("O");
			this.pieceShape = new OPiece(this.numCols);
			break;
		case 3:
			System.out.println("J");
			this.pieceShape = new JPiece(this.numCols);
			break;
		case 4:
			System.out.println("T");
			this.pieceShape = new TPiece(this.numCols);
			break;
		case 5:
			System.out.println("Z");
			this.pieceShape = new ZPiece(this.numCols);
			break;

		case 6:
			System.out.println("Z");
			this.pieceShape = new SPiece(this.numCols);
			break;

		}
		// return this.pieceShape;
	}

	public void gameOver() {
		this.gameOver.setText("GAME OVER");
		executor.shutdown();
	}

	public void keyPressed(KeyEvent e) {
		System.out.println("pressed");
		int c = e.getKeyCode();
		if (c == KeyEvent.VK_UP) {
			// b.y--;
		} else if (c == KeyEvent.VK_DOWN) {
			// b.y++;
		} else if (c == KeyEvent.VK_LEFT) {
			System.out.println("left");
			if (column != 0) {
				column--;
			}
		} else if (c == KeyEvent.VK_RIGHT) {
			System.out.println("right");
			if (column != 9) {
				column++;
			}
		}
		// System.out.println (b.x);
		repaint();
	}

	@Override
	public void keyReleased(KeyEvent arg0) {
		// TODO Auto-generated method stub
		System.out.println("released");
	}

	@Override
	public void keyTyped(KeyEvent arg0) {
		// TODO Auto-generated method stub
		System.out.println("typed");
	}

	private void refreshColumnValues() {
		column1 = pieceShape.getColumn1();
		column2 = pieceShape.getColumn2();
		column3 = pieceShape.getColumn3();
		column4 = pieceShape.getColumn4();

	}

	private void refreshRowValues() {

		row1 = pieceShape.getRow1();
		row2 = pieceShape.getRow2();
		row3 = pieceShape.getRow3();
		row4 = pieceShape.getRow4();

	}
}